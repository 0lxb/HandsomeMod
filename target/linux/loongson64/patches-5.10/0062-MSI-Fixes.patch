From 9e4576c4ff2d6fee4c5f9120d4f052ece55310ff Mon Sep 17 00:00:00 2001
From: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date: Fri, 1 May 2020 12:30:50 +0800
Subject: [PATCH 62/81] MSI Fixes

Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
---
 drivers/irqchip/irq-loongson-pch-msi.c | 64 ++++++++++++--------------
 1 file changed, 30 insertions(+), 34 deletions(-)

diff --git a/drivers/irqchip/irq-loongson-pch-msi.c b/drivers/irqchip/irq-loongson-pch-msi.c
index 64b7e5abaa..c4ba2a954b 100644
--- a/drivers/irqchip/irq-loongson-pch-msi.c
+++ b/drivers/irqchip/irq-loongson-pch-msi.c
@@ -16,7 +16,7 @@
 #include <linux/slab.h>
 
 struct pch_msi_data {
-	spinlock_t		msi_map_lock;
+	struct mutex		msi_map_lock;
 	phys_addr_t		doorbell;
 	u32			irq_first;		/* The vectoe number that MSIs start */
 	u32			num_irqs;		/* The number of vector for MSIs */
@@ -36,7 +36,7 @@ static void pch_msi_unmask_msi_irq(struct irq_data *d)
 }
 
 static struct irq_chip pch_msi_irq_chip = {
-	.name			= "PCH MSI",
+	.name			= "PCH PCI MSI",
 	.irq_mask		= pch_msi_mask_msi_irq,
 	.irq_unmask		= pch_msi_unmask_msi_irq,
 	.irq_ack		= irq_chip_ack_parent,
@@ -47,17 +47,16 @@ static int pch_msi_allocate_hwirq(struct pch_msi_data *priv, int num_req)
 {
 	int first;
 
-	spin_lock(&priv->msi_map_lock);
+	mutex_lock(&priv->msi_map_lock);
 
 	first = bitmap_find_free_region(priv->msi_map, priv->num_irqs,
 					get_count_order(num_req));
 	if (first < 0) {
-		spin_unlock(&priv->msi_map_lock);
+		mutex_unlock(&priv->msi_map_lock);
 		return -ENOSPC;
 	}
 
-	bitmap_set(priv->msi_map, first, num_req);
-	spin_unlock(&priv->msi_map_lock);
+	mutex_unlock(&priv->msi_map_lock);
 
 	return priv->irq_first + first;
 }
@@ -67,9 +66,9 @@ static void pch_msi_free_hwirq(struct pch_msi_data *priv,
 {
 	int first = hwirq - priv->irq_first;
 
-	spin_lock(&priv->msi_map_lock);
-	bitmap_clear(priv->msi_map, first, num_req);
-	spin_unlock(&priv->msi_map_lock);
+	mutex_lock(&priv->msi_map_lock);
+	bitmap_release_region(priv->msi_map, first, get_count_order(num_req));
+	mutex_unlock(&priv->msi_map_lock);
 }
 
 static void pch_msi_compose_msi_msg(struct irq_data *data,
@@ -89,7 +88,7 @@ static struct msi_domain_info pch_msi_domain_info = {
 };
 
 static struct irq_chip middle_irq_chip = {
-	.name			= "PCH MSI Middle",
+	.name			= "PCH MSI",
 	.irq_mask		= irq_chip_mask_parent,
 	.irq_unmask		= irq_chip_unmask_parent,
 	.irq_ack		= irq_chip_ack_parent,
@@ -111,9 +110,6 @@ static int pch_msi_parent_domain_alloc(struct irq_domain *domain,
 	if (ret)
 		return ret;
 
-	irq_domain_set_hwirq_and_chip(domain, virq, hwirq,
-					&middle_irq_chip, NULL);
-
 	return 0;
 }
 
@@ -140,10 +136,9 @@ static int pch_msi_middle_domain_alloc(struct irq_domain *domain,
 	return 0;
 
 err_hwirq:
-	while (--i >= 0)
-		irq_domain_free_irqs_parent(domain, virq, i);
-
 	pch_msi_free_hwirq(priv, hwirq, nr_irqs);
+	irq_domain_free_irqs_parent(domain, virq, i - 1);
+
 	return err;
 }
 
@@ -165,31 +160,27 @@ static const struct irq_domain_ops pch_msi_middle_domain_ops = {
 
 static int pch_msi_init_domains(struct pch_msi_data *priv,
 				struct device_node *node,
-				struct device_node *parent)
+				struct irq_domain *parent)
 {
-	struct irq_domain *middle_domain, *msi_domain, *parent_domain;
+	struct irq_domain *middle_domain, *msi_domain;
 
-	parent_domain = irq_find_host(parent);
-	if (!parent_domain) {
-		pr_err("Failed to find the parent domain\n");
-		return -ENXIO;
-	}
-
-	middle_domain = irq_domain_add_linear(NULL, priv->num_irqs,
-					    &pch_msi_middle_domain_ops,
-					    priv);
+	middle_domain = irq_domain_create_linear(of_node_to_fwnode(node),
+						priv->num_irqs,
+						&pch_msi_middle_domain_ops,
+						priv);
 	if (!middle_domain) {
 		pr_err("Failed to create the MSI middle domain\n");
 		return -ENOMEM;
 	}
 
-	middle_domain->parent = parent_domain;
+	middle_domain->parent = parent;
+	irq_domain_update_bus_token(middle_domain, DOMAIN_BUS_NEXUS);
 
 	msi_domain = pci_msi_create_irq_domain(of_node_to_fwnode(node),
 					       &pch_msi_domain_info,
 					       middle_domain);
 	if (!msi_domain) {
-		pr_err("Failed to create MSI domain\n");
+		pr_err("Failed to create PCI MSI domain\n");
 		irq_domain_remove(middle_domain);
 		return -ENOMEM;
 	}
@@ -201,14 +192,21 @@ static int pch_msi_init(struct device_node *node,
 			    struct device_node *parent)
 {
 	struct pch_msi_data *priv;
+	struct irq_domain *parent_domain;
 	struct resource res;
 	int ret;
 
+	parent_domain = irq_find_host(parent);
+	if (!parent_domain) {
+		pr_err("Failed to find the parent domain\n");
+		return -ENXIO;
+	}
+
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	spin_lock_init(&priv->msi_map_lock);
+	mutex_init(&priv->msi_map_lock);
 
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
@@ -232,9 +230,7 @@ static int pch_msi_init(struct device_node *node,
 		goto err_priv;
 	}
 
-	priv->msi_map = kcalloc(BITS_TO_LONGS(priv->num_irqs),
-				sizeof(*priv->msi_map),
-				GFP_KERNEL);
+	priv->msi_map = bitmap_alloc(priv->num_irqs, GFP_KERNEL);
 	if (!priv->msi_map) {
 		ret = -ENOMEM;
 		goto err_priv;
@@ -243,7 +239,7 @@ static int pch_msi_init(struct device_node *node,
 	pr_debug("Registering %d MSIs, starting at %d\n",
 		 priv->num_irqs, priv->irq_first);
 
-	ret = pch_msi_init_domains(priv, node, parent);
+	ret = pch_msi_init_domains(priv, node, parent_domain);
 	if (ret)
 		goto err_map;
 
-- 
2.31.1

