From 25dccf586764865f8bb787065ab4940fc48dfde5 Mon Sep 17 00:00:00 2001
From: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date: Tue, 28 Apr 2020 14:04:41 +0800
Subject: [PATCH 51/81] pch pci fix

Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
---
 drivers/irqchip/Kconfig                |   1 +
 drivers/irqchip/irq-loongson-pch-pic.c | 116 +++++++++++--------------
 2 files changed, 54 insertions(+), 63 deletions(-)

diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 9f2935418f..0b6b826dd8 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -545,6 +545,7 @@ config LOONGSON_PCH_PIC
 	depends on MACH_LOONGSON64 || COMPILE_TEST
 	default MACH_LOONGSON64
 	select IRQ_DOMAIN_HIERARCHY
+	select IRQ_FASTEOI_HIERARCHY_HANDLERS
 	help
 	  Support for the Loongson PCH PIC Controller.
 
diff --git a/drivers/irqchip/irq-loongson-pch-pic.c b/drivers/irqchip/irq-loongson-pch-pic.c
index 717ab83350..3150527586 100644
--- a/drivers/irqchip/irq-loongson-pch-pic.c
+++ b/drivers/irqchip/irq-loongson-pch-pic.c
@@ -34,30 +34,36 @@
 #define PIC_REG_BIT(irq_id)	((irq_id) % PIC_COUNT_PER_REG)
 
 struct pch_pic {
-	void __iomem *base;
-	struct irq_domain *pic_domain;
-	int	ht_vec_base;
-	raw_spinlock_t pic_lock;
+	void __iomem		*base;
+	struct irq_domain	*pic_domain;
+	u32			ht_vec_base;
+	raw_spinlock_t		pic_lock;
 };
 
-static void pch_pic_bitset(void __iomem *addr, int bit)
+static void pch_pic_bitset(struct pch_pic *priv, int offset, int bit)
 {
+	void __iomem *addr = priv->base + offset + PIC_REG_IDX(bit) * 4;
+	unsigned long flags;
 	u32 reg;
 
-	addr += PIC_REG_IDX(bit) * 4;
+	raw_spin_lock_irqsave(&priv->pic_lock, flags);
 	reg = readl(addr);
 	reg |= BIT(PIC_REG_BIT(bit));
 	writel(reg, addr);
+	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
 }
 
-static void pch_pic_bitclr(void __iomem *addr, int bit)
+static void pch_pic_bitclr(struct pch_pic *priv, int offset, int bit)
 {
+	void __iomem *addr = priv->base + offset + PIC_REG_IDX(bit) * 4;
+	unsigned long flags;
 	u32 reg;
 
-	addr += PIC_REG_IDX(bit) * 4;
+	raw_spin_lock_irqsave(&priv->pic_lock, flags);
 	reg = readl(addr);
 	reg &= ~BIT(PIC_REG_BIT(bit));
 	writel(reg, addr);
+	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
 }
 
 static void pch_pic_eoi_irq(struct irq_data *d)
@@ -72,22 +78,16 @@ static void pch_pic_eoi_irq(struct irq_data *d)
 static void pch_pic_mask_irq(struct irq_data *d)
 {
 	struct pch_pic *priv = irq_data_get_irq_chip_data(d);
-	unsigned long flags;
 
-	raw_spin_lock_irqsave(&priv->pic_lock, flags);
-	pch_pic_bitset(priv->base + PCH_PIC_MASK, d->hwirq);
-	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
+	pch_pic_bitset(priv, PCH_PIC_MASK, d->hwirq);
 	irq_chip_mask_parent(d);
 }
 
 static void pch_pic_unmask_irq(struct irq_data *d)
 {
 	struct pch_pic *priv = irq_data_get_irq_chip_data(d);
-	unsigned long flags;
 
-	raw_spin_lock_irqsave(&priv->pic_lock, flags);
-	pch_pic_bitclr(priv->base + PCH_PIC_MASK, d->hwirq);
-	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
+	pch_pic_bitclr(priv, PCH_PIC_MASK, d->hwirq);
 	irq_chip_unmask_parent(d);
 }
 
@@ -95,61 +95,38 @@ static int pch_pic_set_type(struct irq_data *d, unsigned int type)
 {
 	struct pch_pic *priv = irq_data_get_irq_chip_data(d);
 	int ret = 0;
-	unsigned long flags;
 
-	raw_spin_lock_irqsave(&priv->pic_lock, flags);
 	switch (type) {
 	case IRQ_TYPE_EDGE_RISING:
-		pch_pic_bitset(priv->base + PCH_PIC_EDGE, d->hwirq);
-		pch_pic_bitclr(priv->base + PCH_PIC_POL, d->hwirq);
+		pch_pic_bitset(priv, PCH_PIC_EDGE, d->hwirq);
+		pch_pic_bitclr(priv, PCH_PIC_POL, d->hwirq);
 		break;
 	case IRQ_TYPE_EDGE_FALLING:
-		pch_pic_bitset(priv->base + PCH_PIC_EDGE, d->hwirq);
-		pch_pic_bitset(priv->base + PCH_PIC_POL, d->hwirq);
+		pch_pic_bitset(priv, PCH_PIC_EDGE, d->hwirq);
+		pch_pic_bitset(priv, PCH_PIC_POL, d->hwirq);
 		break;
 	case IRQ_TYPE_LEVEL_HIGH:
-		pch_pic_bitclr(priv->base + PCH_PIC_EDGE, d->hwirq);
-		pch_pic_bitclr(priv->base + PCH_PIC_POL, d->hwirq);
+		pch_pic_bitclr(priv, PCH_PIC_EDGE, d->hwirq);
+		pch_pic_bitclr(priv, PCH_PIC_POL, d->hwirq);
 		break;
 	case IRQ_TYPE_LEVEL_LOW:
-		pch_pic_bitclr(priv->base + PCH_PIC_EDGE, d->hwirq);
-		pch_pic_bitset(priv->base + PCH_PIC_POL, d->hwirq);
+		pch_pic_bitclr(priv, PCH_PIC_EDGE, d->hwirq);
+		pch_pic_bitset(priv, PCH_PIC_POL, d->hwirq);
 		break;
 	default:
 		ret = -EINVAL;
 		break;
 	}
-	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
 
 	return ret;
 }
 
-static void pch_pic_enable_irq(struct irq_data *d)
-{
-	struct pch_pic *priv = irq_data_get_irq_chip_data(d);
-	u8 htvec = d->hwirq + priv->ht_vec_base;
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&priv->pic_lock, flags);
-	writeb(htvec, priv->base + PCH_INT_HTVEC(d->hwirq));
-	/* Hardcode to HT0 Lo */
-	writeb(1, priv->base + PCH_INT_ROUTE(d->hwirq));
-	/* Clear auto bounce, we don't need that */
-	pch_pic_bitclr(priv->base + PCH_PIC_AUTO0, d->hwirq);
-	pch_pic_bitclr(priv->base + PCH_PIC_AUTO1, d->hwirq);
-	/* Enable HTMSI transformer */
-	pch_pic_bitset(priv->base + PCH_PIC_HTMSI_EN, d->hwirq);
-	raw_spin_unlock_irqrestore(&priv->pic_lock, flags);
-	pch_pic_unmask_irq(d);
-}
-
 static struct irq_chip pch_pic_irq_chip = {
 	.name			= "PCH PIC",
-	.irq_eoi		= pch_pic_eoi_irq,
 	.irq_mask		= pch_pic_mask_irq,
 	.irq_unmask		= pch_pic_unmask_irq,
-	.irq_enable		= pch_pic_enable_irq,
-	.irq_disable	= pch_pic_mask_irq,
+	.irq_ack		= irq_chip_ack_parent,
+	.irq_eoi		= pch_pic_eoi_irq,
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
 	.irq_set_type		= pch_pic_set_type,
 };
@@ -175,26 +152,38 @@ static int pch_pic_alloc(struct irq_domain *domain, unsigned int virq,
 
 	irq_domain_set_info(domain, virq, hwirq,
 			    &pch_pic_irq_chip, priv,
-			    handle_fasteoi_irq, NULL, NULL);
+			    handle_fasteoi_ack_irq, NULL, NULL);
 	irq_set_probe(virq);
 
 	return 0;
 }
 
 static const struct irq_domain_ops pch_pic_domain_ops = {
-	.translate = irq_domain_translate_twocell,
-	.alloc	= pch_pic_alloc,
-	.free	= irq_domain_free_irqs_parent,
+	.translate	= irq_domain_translate_twocell,
+	.alloc		= pch_pic_alloc,
+	.free		= irq_domain_free_irqs_parent,
 };
 
 static void pch_pic_reset(struct pch_pic *priv)
 {
-	u32 idx;
+	int i;
 
-	/* Clear IRQ cause registers, mask all interrupts */
-	for (idx = 0; idx < PIC_REG_COUNT; idx++) {
-		writel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_MASK + 4 * idx);
-		writel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_CLR + 4 * idx);
+	for (i = 0; i < PIC_COUNT; i++) {
+		/* Write vectore ID */
+		writeb(priv->ht_vec_base + i, priv->base + PCH_INT_HTVEC(i));
+		/* Hardcode to HT0 Lo */
+		writeb(1, priv->base + PCH_INT_ROUTE(i));
+	}
+
+	for (i = 0; i < PIC_REG_COUNT; i++) {
+		/* Clear IRQ cause registers, mask all interrupts */
+		writel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_MASK + 4 * i);
+		writel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_CLR + 4 * i);
+		/* Clear auto bounce, we don't need that */
+		writel_relaxed(0, priv->base + PCH_PIC_AUTO0 + 4 * i);
+		writel_relaxed(0, priv->base + PCH_PIC_AUTO1 + 4 * i);
+		/* Enable HTMSI transformer */
+		writel_relaxed(0xFFFFFFFF, priv->base + PCH_PIC_HTMSI_EN + 4 * i);
 	}
 }
 
@@ -204,7 +193,6 @@ static int pch_pic_of_init(struct device_node *node,
 	struct pch_pic *priv;
 	struct irq_domain *parent_domain;
 	int err;
-	u32 ht_vec_base;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -225,10 +213,12 @@ static int pch_pic_of_init(struct device_node *node,
 	}
 
 	if (of_property_read_u32(node, "loongson,pic-base-vec",
-				&ht_vec_base))
-		priv->ht_vec_base = 64;
-	else
-		priv->ht_vec_base = ht_vec_base;
+				&priv->ht_vec_base)) {
+		pr_err("Failed to determine pic-base-vec\n");
+		err = -EINVAL;
+		goto iounmap_base;
+	}
+	
 
 	priv->pic_domain = irq_domain_create_hierarchy(parent_domain, 0,
 						     PIC_COUNT,
-- 
2.31.1

