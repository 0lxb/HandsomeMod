From a2b1e3bd49a8555e1d73c16a1fb864bc5e04a4a5 Mon Sep 17 00:00:00 2001
From: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date: Fri, 1 May 2020 00:21:00 +0800
Subject: [PATCH 59/81] etnaviv: Loongson PCI

Yes, I fullly understood it's crap, but crap can work!!!!!
It's ported from my 4.19 tree so using legacy API.

Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
---
 drivers/gpu/drm/drm_pci.c             |   3 +-
 drivers/gpu/drm/etnaviv/Kconfig       |   1 +
 drivers/gpu/drm/etnaviv/etnaviv_drv.c | 227 +++++++++++++++++++++++++-
 drivers/gpu/drm/etnaviv/etnaviv_drv.h |   4 +
 drivers/gpu/drm/etnaviv/etnaviv_gem.c |  29 +++-
 drivers/gpu/drm/etnaviv/etnaviv_gpu.c |  17 +-
 include/drm/drm_pci.h                 |   4 +
 7 files changed, 275 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/drm_pci.c b/drivers/gpu/drm/drm_pci.c
index 81aa215619..b52b1fe2bc 100644
--- a/drivers/gpu/drm/drm_pci.c
+++ b/drivers/gpu/drm/drm_pci.c
@@ -192,7 +192,7 @@ static void drm_pci_agp_init(struct drm_device *dev)
 	}
 }
 
-static int drm_get_pci_dev(struct pci_dev *pdev,
+int drm_get_pci_dev(struct pci_dev *pdev,
 			   const struct pci_device_id *ent,
 			   struct drm_driver *driver)
 {
@@ -237,6 +237,7 @@ static int drm_get_pci_dev(struct pci_dev *pdev,
 	drm_dev_put(dev);
 	return ret;
 }
+EXPORT_SYMBOL(drm_get_pci_dev);
 
 /**
  * drm_legacy_pci_init - shadow-attach a legacy DRM PCI driver
diff --git a/drivers/gpu/drm/etnaviv/Kconfig b/drivers/gpu/drm/etnaviv/Kconfig
index faa7fc68b0..d616357cb3 100644
--- a/drivers/gpu/drm/etnaviv/Kconfig
+++ b/drivers/gpu/drm/etnaviv/Kconfig
@@ -11,6 +11,7 @@ config DRM_ETNAVIV
 	select WANT_DEV_COREDUMP
 	select CMA if HAVE_DMA_CONTIGUOUS
 	select DMA_CMA if HAVE_DMA_CONTIGUOUS
+	select DRM_LEGACY
 	select DRM_SCHED
 	help
 	  DRM driver for Vivante GPUs.
diff --git a/drivers/gpu/drm/etnaviv/etnaviv_drv.c b/drivers/gpu/drm/etnaviv/etnaviv_drv.c
index a8685b2e18..82f48c5efe 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_drv.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_drv.c
@@ -3,10 +3,14 @@
  * Copyright (C) 2015-2018 Etnaviv Project
  */
 
+#include <linux/clk.h>
 #include <linux/component.h>
 #include <linux/dma-mapping.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/thermal.h>
 #include <linux/uaccess.h>
 
 #include <drm/drm_debugfs.h>
@@ -14,6 +18,7 @@
 #include <drm/drm_file.h>
 #include <drm/drm_ioctl.h>
 #include <drm/drm_of.h>
+#include <drm/drm_pci.h>
 #include <drm/drm_prime.h>
 
 #include "etnaviv_cmdbuf.h"
@@ -22,6 +27,7 @@
 #include "etnaviv_gem.h"
 #include "etnaviv_mmu.h"
 #include "etnaviv_perfmon.h"
+#include "etnaviv_sched.h"
 
 /*
  * DRM operations:
@@ -462,6 +468,190 @@ static int etnaviv_ioctl_pm_query_sig(struct drm_device *dev, void *data,
 	return etnaviv_pm_query_sig(gpu, args);
 }
 
+static int etnaviv_load(struct drm_device *dev, unsigned long flags)
+{
+	int ret, err;
+	struct resource *res;
+	struct etnaviv_gpu *gpu;
+	struct etnaviv_drm_private *priv;
+
+	if (!dev->pdev)
+		return 0;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	dev->dev_private = priv;
+	mutex_init(&priv->gem_lock);
+	INIT_LIST_HEAD(&priv->gem_list);
+	priv->num_gpus = 0;
+
+	priv->cmdbuf_suballoc = etnaviv_cmdbuf_suballoc_new(dev->dev);
+	if (IS_ERR(priv->cmdbuf_suballoc)) {
+		dev_err(dev->dev, "Failed to create cmdbuf suballocator\n");
+		ret = PTR_ERR(priv->cmdbuf_suballoc);
+		goto out_free_priv;
+	}
+
+	gpu = devm_kzalloc(dev->dev, sizeof(*gpu), GFP_KERNEL);
+	if (!gpu) {
+		ret = -ENOMEM;
+		goto out_destroy_suballoc;
+	}
+
+	gpu->dev = dev->dev;
+	mutex_init(&gpu->lock);
+	mutex_init(&gpu->fence_lock);
+
+	/* Map registers: */
+	res = &dev->pdev->resource[0];
+	gpu->mmio = devm_ioremap_resource(dev->dev, res);
+	if (IS_ERR(gpu->mmio)) {
+		ret = PTR_ERR(gpu->mmio);
+		goto out_destroy_suballoc;
+	}
+
+#ifdef CONFIG_MACH_LOONGSON64
+	dma_set_mask_and_coherent(dev->dev, DMA_BIT_MASK(32));
+#endif
+
+	/* Get Interrupt: */
+	gpu->irq = dev->pdev->irq;
+	if (gpu->irq < 0) {
+		dev_err(dev->dev, "failed to get irq: %d\n", gpu->irq);
+		ret = gpu->irq;
+		goto out_destroy_suballoc;
+	}
+
+	err = devm_request_irq(dev->dev, gpu->irq, irq_handler, 0,
+			       dev_name(gpu->dev), gpu);
+	if (err) {
+		dev_err(dev->dev, "failed to request IRQ%u: %d\n", gpu->irq, err);
+		ret = err;
+		goto out_destroy_suballoc;
+	}
+
+	/* Get Clocks: */
+	gpu->clk_reg = NULL;
+	gpu->clk_bus = NULL;
+	gpu->clk_core = NULL;
+	gpu->clk_shader = NULL;
+	gpu->base_rate_core = clk_get_rate(gpu->clk_core);
+	gpu->base_rate_shader = clk_get_rate(gpu->clk_shader);
+
+	/* TODO: figure out max mapped size */
+	dev_set_drvdata(dev->dev, gpu);
+
+	/*
+	 * We treat the device as initially suspended.  The runtime PM
+	 * autosuspend delay is rather arbitary: no measurements have
+	 * yet been performed to determine an appropriate value.
+	 */
+	pm_runtime_use_autosuspend(gpu->dev);
+	pm_runtime_set_autosuspend_delay(gpu->dev, 200);
+
+	if (IS_ENABLED(CONFIG_DRM_ETNAVIV_THERMAL)) {
+		gpu->cooling = thermal_cooling_device_register((char *)dev_name(dev->dev), gpu, &cooling_ops);
+		if (IS_ERR(gpu->cooling)) {
+			ret = PTR_ERR(gpu->cooling);
+			goto out_destroy_suballoc;
+		}
+	}
+
+	gpu->wq = alloc_ordered_workqueue(dev_name(dev->dev), 0);
+	if (!gpu->wq) {
+		ret = -ENOMEM;
+		goto out_thermal;
+	}
+
+	ret = etnaviv_sched_init(gpu);
+	if (ret)
+		goto out_workqueue;
+
+#ifdef CONFIG_PM
+	ret = pm_runtime_get_sync(gpu->dev);
+#else
+	ret = etnaviv_gpu_clk_enable(gpu);
+#endif
+	if (ret < 0)
+		goto out_sched;
+
+
+	gpu->drm = dev;
+	gpu->fence_context = dma_fence_context_alloc(1);
+	idr_init(&gpu->fence_idr);
+	spin_lock_init(&gpu->fence_spinlock);
+
+	INIT_WORK(&gpu->sync_point_work, sync_point_worker);
+	init_waitqueue_head(&gpu->fence_event);
+
+	priv->gpu[priv->num_gpus++] = gpu;
+
+	pm_runtime_mark_last_busy(gpu->dev);
+	pm_runtime_put_autosuspend(gpu->dev);
+
+	load_gpu(dev);
+
+	return 0;
+
+out_sched:
+	etnaviv_sched_fini(gpu);
+
+out_workqueue:
+	destroy_workqueue(gpu->wq);
+
+out_thermal:
+	if (IS_ENABLED(CONFIG_DRM_ETNAVIV_THERMAL))
+		thermal_cooling_device_unregister(gpu->cooling);
+
+out_destroy_suballoc:
+	etnaviv_cmdbuf_suballoc_destroy(priv->cmdbuf_suballoc);
+
+out_free_priv:
+	kfree(priv);
+
+	return ret;
+}
+
+static void etnaviv_unload(struct drm_device *dev)
+{
+	struct etnaviv_gpu *gpu = dev_get_drvdata(dev->dev);
+
+	if (!dev->pdev)
+		return;
+
+	DBG("%s", dev_name(gpu->dev));
+
+	flush_workqueue(gpu->wq);
+	destroy_workqueue(gpu->wq);
+
+	etnaviv_sched_fini(gpu);
+
+#ifdef CONFIG_PM
+	pm_runtime_get_sync(gpu->dev);
+	pm_runtime_put_sync_suspend(gpu->dev);
+#else
+	etnaviv_gpu_hw_suspend(gpu);
+#endif
+
+	if (gpu->initialized) {
+		etnaviv_cmdbuf_free(&gpu->buffer);
+		etnaviv_iommu_global_fini(gpu);
+		gpu->initialized = false;
+	}
+
+	gpu->drm = NULL;
+	idr_destroy(&gpu->fence_idr);
+
+	if (IS_ENABLED(CONFIG_DRM_ETNAVIV_THERMAL))
+		thermal_cooling_device_unregister(gpu->cooling);
+	gpu->cooling = NULL;
+	pm_runtime_disable(dev->dev);
+
+	return;
+}
+
 static const struct drm_ioctl_desc etnaviv_ioctls[] = {
 #define ETNA_IOCTL(n, func, flags) \
 	DRM_IOCTL_DEF_DRV(ETNAVIV_##n, etnaviv_ioctl_##func, flags)
@@ -498,6 +688,8 @@ static const struct file_operations fops = {
 
 static struct drm_driver etnaviv_drm_driver = {
 	.driver_features    = DRIVER_GEM | DRIVER_RENDER,
+	.load               = etnaviv_load,
+	.unload             = etnaviv_unload,
 	.open               = etnaviv_open,
 	.postclose           = etnaviv_postclose,
 	.gem_free_object_unlocked = etnaviv_gem_free_object,
@@ -529,9 +721,9 @@ static struct drm_driver etnaviv_drm_driver = {
  */
 static int etnaviv_bind(struct device *dev)
 {
-	struct etnaviv_drm_private *priv;
-	struct drm_device *drm;
 	int ret;
+	struct drm_device *drm;
+	struct etnaviv_drm_private *priv;
 
 	drm = drm_dev_alloc(&etnaviv_drm_driver, dev);
 	if (IS_ERR(drm))
@@ -665,6 +857,32 @@ static struct platform_driver etnaviv_platform_driver = {
 
 static struct platform_device *etnaviv_drm;
 
+static struct pci_device_id etnaviv_pci_devices[] = {
+	{PCI_VDEVICE(LOONGSON, 0x7a05)},
+	{PCI_VDEVICE(LOONGSON, 0x7a15)},
+	{0, 0, 0, 0, 0, 0, 0}
+};
+
+static int etnaviv_pci_probe(struct pci_dev *pdev,
+				 const struct pci_device_id *ent)
+
+{
+	return drm_get_pci_dev(pdev, ent, &etnaviv_drm_driver);
+}
+
+static void etnaviv_pci_remove(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+	drm_put_dev(dev);
+}
+
+static struct pci_driver etnaviv_pci_driver = {
+	.name		= "etnaviv-pci",
+	.probe		= etnaviv_pci_probe,
+	.remove		= etnaviv_pci_remove,
+	.id_table	= etnaviv_pci_devices,
+};
+
 static int __init etnaviv_init(void)
 {
 	struct platform_device *pdev;
@@ -681,6 +899,10 @@ static int __init etnaviv_init(void)
 	if (ret != 0)
 		goto unregister_gpu_driver;
 
+	ret = pci_register_driver(&etnaviv_pci_driver);
+	if (ret != 0)
+		goto unregister_platform_driver;
+
 	/*
 	 * If the DT contains at least one available GPU device, instantiate
 	 * the DRM platform device.
@@ -730,6 +952,7 @@ module_init(etnaviv_init);
 static void __exit etnaviv_exit(void)
 {
 	platform_device_unregister(etnaviv_drm);
+	pci_unregister_driver(&etnaviv_pci_driver);
 	platform_driver_unregister(&etnaviv_platform_driver);
 	platform_driver_unregister(&etnaviv_gpu_driver);
 }
diff --git a/drivers/gpu/drm/etnaviv/etnaviv_drv.h b/drivers/gpu/drm/etnaviv/etnaviv_drv.h
index 4d8dc9236e..a598df6a86 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_drv.h
+++ b/drivers/gpu/drm/etnaviv/etnaviv_drv.h
@@ -45,6 +45,8 @@ struct etnaviv_drm_private {
 	struct list_head gem_list;
 };
 
+extern struct thermal_cooling_device_ops cooling_ops;
+
 int etnaviv_ioctl_gem_submit(struct drm_device *dev, void *data,
 		struct drm_file *file);
 
@@ -81,6 +83,8 @@ void etnaviv_validate_init(void);
 bool etnaviv_cmd_validate_one(struct etnaviv_gpu *gpu,
 	u32 *stream, unsigned int size,
 	struct drm_etnaviv_gem_submit_reloc *relocs, unsigned int reloc_size);
+irqreturn_t irq_handler(int irq, void *data);
+void sync_point_worker(struct work_struct *work);
 
 #ifdef CONFIG_DEBUG_FS
 void etnaviv_gem_describe_objects(struct etnaviv_drm_private *priv,
diff --git a/drivers/gpu/drm/etnaviv/etnaviv_gem.c b/drivers/gpu/drm/etnaviv/etnaviv_gem.c
index dc9ef302f5..e1e11efc9b 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_gem.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_gem.c
@@ -8,6 +8,8 @@
 #include <linux/shmem_fs.h>
 #include <linux/spinlock.h>
 #include <linux/vmalloc.h>
+#include <linux/dma-noncoherent.h>
+#include <drm/drm_cache.h>
 
 #include "etnaviv_drv.h"
 #include "etnaviv_gem.h"
@@ -350,6 +352,7 @@ void *etnaviv_gem_vmap(struct drm_gem_object *obj)
 
 static void *etnaviv_gem_vmap_impl(struct etnaviv_gem_object *obj)
 {
+	pgprot_t prot;
 	struct page **pages;
 
 	lockdep_assert_held(&obj->lock);
@@ -358,8 +361,19 @@ static void *etnaviv_gem_vmap_impl(struct etnaviv_gem_object *obj)
 	if (IS_ERR(pages))
 		return NULL;
 
-	return vmap(pages, obj->base.size >> PAGE_SHIFT,
-			VM_MAP, pgprot_writecombine(PAGE_KERNEL));
+	switch (obj->flags) {
+		case ETNA_BO_CACHED:
+			prot = PAGE_KERNEL;
+			break;
+		case ETNA_BO_UNCACHED:
+			prot = pgprot_noncached(PAGE_KERNEL);
+			break;
+		case ETNA_BO_WC:
+		default:
+			prot = pgprot_writecombine(PAGE_KERNEL);
+	}
+
+	return vmap(pages, obj->base.size >> PAGE_SHIFT, VM_MAP, prot);
 }
 
 static inline enum dma_data_direction etnaviv_op_to_dma_dir(u32 op)
@@ -403,7 +417,7 @@ int etnaviv_gem_cpu_prep(struct drm_gem_object *obj, u32 op,
 			return ret == 0 ? -ETIMEDOUT : ret;
 	}
 
-	if (etnaviv_obj->flags & ETNA_BO_CACHED) {
+	if (!dev_is_dma_coherent(dev->dev) && etnaviv_obj->flags & ETNA_BO_CACHED) {
 		dma_sync_sg_for_cpu(dev->dev, etnaviv_obj->sgt->sgl,
 				    etnaviv_obj->sgt->nents,
 				    etnaviv_op_to_dma_dir(op));
@@ -418,7 +432,7 @@ int etnaviv_gem_cpu_fini(struct drm_gem_object *obj)
 	struct drm_device *dev = obj->dev;
 	struct etnaviv_gem_object *etnaviv_obj = to_etnaviv_bo(obj);
 
-	if (etnaviv_obj->flags & ETNA_BO_CACHED) {
+	if (!dev_is_dma_coherent(dev->dev) && etnaviv_obj->flags & ETNA_BO_CACHED) {
 		/* fini without a prep is almost certainly a userspace error */
 		WARN_ON(etnaviv_obj->last_cpu_prep_op == 0);
 		dma_sync_sg_for_device(dev->dev, etnaviv_obj->sgt->sgl,
@@ -587,6 +601,13 @@ static int etnaviv_gem_new_impl(struct drm_device *dev, u32 size, u32 flags,
 	if (!etnaviv_obj)
 		return -ENOMEM;
 
+	if (!drm_arch_can_wc_memory()) {
+		if (dev_is_dma_coherent(dev->dev))
+			flags = ETNA_BO_CACHED;
+		else
+			flags = ETNA_BO_UNCACHED;
+	}
+
 	etnaviv_obj->flags = flags;
 	etnaviv_obj->ops = ops;
 
diff --git a/drivers/gpu/drm/etnaviv/etnaviv_gpu.c b/drivers/gpu/drm/etnaviv/etnaviv_gpu.c
index a31eeff2b2..f2f1eb7fef 100644
--- a/drivers/gpu/drm/etnaviv/etnaviv_gpu.c
+++ b/drivers/gpu/drm/etnaviv/etnaviv_gpu.c
@@ -434,6 +434,13 @@ static void etnaviv_hw_identify(struct etnaviv_gpu *gpu)
 				gpu_read(gpu, VIVS_HI_CHIP_MINOR_FEATURE_5);
 	}
 
+	/* Loongson Workaround */
+	if (gpu->identity.model == chipModel_GC1000 &&
+	    gpu->identity.revision == 0x5037) {
+		gpu->identity.minor_features0 &= ~chipMinorFeatures0_HZ;
+		gpu->identity.minor_features2 &= ~chipMinorFeatures2_DYNAMIC_FREQUENCY_SCALING;
+	}
+
 	/* GC600 idle register reports zero bits where modules aren't present */
 	if (gpu->identity.model == chipModel_GC600)
 		gpu->idle_mask = VIVS_HI_IDLE_STATE_TX |
@@ -1373,7 +1380,7 @@ struct dma_fence *etnaviv_gpu_submit(struct etnaviv_gem_submit *submit)
 	return gpu_fence;
 }
 
-static void sync_point_worker(struct work_struct *work)
+void sync_point_worker(struct work_struct *work)
 {
 	struct etnaviv_gpu *gpu = container_of(work, struct etnaviv_gpu,
 					       sync_point_work);
@@ -1417,7 +1424,7 @@ static void dump_mmu_fault(struct etnaviv_gpu *gpu)
 	}
 }
 
-static irqreturn_t irq_handler(int irq, void *data)
+irqreturn_t irq_handler(int irq, void *data)
 {
 	struct etnaviv_gpu *gpu = data;
 	irqreturn_t ret = IRQ_NONE;
@@ -1635,7 +1642,7 @@ etnaviv_gpu_cooling_set_cur_state(struct thermal_cooling_device *cdev,
 	return 0;
 }
 
-static struct thermal_cooling_device_ops cooling_ops = {
+struct thermal_cooling_device_ops cooling_ops = {
 	.get_max_state = etnaviv_gpu_cooling_get_max_state,
 	.get_cur_state = etnaviv_gpu_cooling_get_cur_state,
 	.set_cur_state = etnaviv_gpu_cooling_set_cur_state,
@@ -1768,6 +1775,10 @@ static int etnaviv_gpu_platform_probe(struct platform_device *pdev)
 	if (IS_ERR(gpu->mmio))
 		return PTR_ERR(gpu->mmio);
 
+#ifdef CONFIG_MACH_LOONGSON64
+	dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));
+#endif
+
 	/* Get Interrupt: */
 	gpu->irq = platform_get_irq(pdev, 0);
 	if (gpu->irq < 0) {
diff --git a/include/drm/drm_pci.h b/include/drm/drm_pci.h
index 3941b0255e..fef7b1a6ee 100644
--- a/include/drm/drm_pci.h
+++ b/include/drm/drm_pci.h
@@ -45,6 +45,10 @@ struct drm_dma_handle *drm_pci_alloc(struct drm_device *dev, size_t size,
 				     size_t align);
 void drm_pci_free(struct drm_device *dev, struct drm_dma_handle * dmah);
 
+int drm_get_pci_dev(struct pci_dev *pdev,
+			   const struct pci_device_id *ent,
+			   struct drm_driver *driver);
+
 #else
 
 static inline struct drm_dma_handle *drm_pci_alloc(struct drm_device *dev,
-- 
2.31.1

